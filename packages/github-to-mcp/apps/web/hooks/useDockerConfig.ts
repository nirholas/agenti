/**
 * useDockerConfig Hook - Generate Docker configuration
 * @copyright 2024-2026 nirholas
 * @license MIT
 */

import { useState, useMemo, useCallback } from 'react';
import type { DockerConfig, DockerExportOptions, ConversionResult } from '@/types';

const DEFAULT_OPTIONS: DockerExportOptions = {
  baseImage: 'node:20-alpine',
  port: 3000,
  exposePorts: [3000],
  envVars: {},
  volumes: [],
  healthCheck: true,
  multiStage: true,
  runAsNonRoot: true,
  labels: true,
};

interface UseDockerConfigReturn {
  options: DockerExportOptions;
  config: DockerConfig;
  setOptions: (options: Partial<DockerExportOptions>) => void;
  resetOptions: () => void;
  downloadAll: () => void;
}

export function useDockerConfig(
  result: ConversionResult,
  serverName: string = 'mcp-server'
): UseDockerConfigReturn {
  const [options, setOptionsState] = useState<DockerExportOptions>(DEFAULT_OPTIONS);

  const sanitizedServerName = useMemo(
    () => serverName.toLowerCase().replace(/[^a-z0-9-]/g, '-').replace(/--+/g, '-'),
    [serverName]
  );

  const setOptions = useCallback((newOptions: Partial<DockerExportOptions>) => {
    setOptionsState(prev => ({ ...prev, ...newOptions }));
  }, []);

  const resetOptions = useCallback(() => {
    setOptionsState(DEFAULT_OPTIONS);
  }, []);

  // Generate Dockerfile content
  const dockerfile = useMemo(() => {
    const isNode = options.baseImage.includes('node');
    const isAlpine = options.baseImage.includes('alpine');

    let content = `# ${sanitizedServerName} MCP Server\n# Generated by github-to-mcp\n\n`;

    if (options.multiStage && isNode) {
      content += `FROM ${options.baseImage} AS builder\nWORKDIR /app\nCOPY package*.json ./\nRUN npm ci --only=production\nCOPY . .\nRUN npm run build --if-present\n\nFROM ${options.baseImage} AS production\n\n`;
    } else {
      content += `FROM ${options.baseImage}\n\n`;
    }

    if (options.labels) {
      content += `LABEL org.opencontainers.image.title="${sanitizedServerName}"\nLABEL org.opencontainers.image.description="MCP Server with ${result.tools.length} tools"\n\n`;
    }

    content += `WORKDIR /app\n\n`;

    if (options.runAsNonRoot) {
      if (isAlpine) {
        content += `RUN addgroup -g 1001 -S mcpuser && adduser -S -D -H -u 1001 -s /sbin/nologin -G mcpuser mcpuser\n\n`;
      } else {
        content += `RUN groupadd -g 1001 mcpuser && useradd -r -u 1001 -g mcpuser mcpuser\n\n`;
      }
    }

    if (options.multiStage && isNode) {
      content += `COPY --from=builder /app/node_modules ./node_modules\nCOPY --from=builder /app/dist ./dist\nCOPY --from=builder /app/package.json ./\n\n`;
    } else if (isNode) {
      content += `COPY package*.json ./\nRUN npm ci --only=production\nCOPY . .\n\n`;
    }

    content += `ENV NODE_ENV=production\nENV PORT=${options.port}\n\n`;
    content += `EXPOSE ${options.port}\n\n`;

    if (options.healthCheck) {
      content += `HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 CMD node -e "require('http').get('http://localhost:${options.port}/health', (r) => process.exit(r.statusCode === 200 ? 0 : 1))"\n\n`;
    }

    if (options.runAsNonRoot) {
      content += `USER mcpuser\n\n`;
    }

    content += isAlpine
      ? `ENTRYPOINT ["dumb-init", "--"]\nCMD ["node", "dist/index.js"]\n`
      : `CMD ["node", "dist/index.js"]\n`;

    return content;
  }, [options, sanitizedServerName, result.tools.length]);

  // Generate docker-compose.yml
  const dockerCompose = useMemo(() => {
    let content = `version: '3.8'\n\nservices:\n  ${sanitizedServerName}:\n    build:\n      context: .\n      dockerfile: Dockerfile\n    container_name: ${sanitizedServerName}\n    restart: unless-stopped\n    ports:\n`;

    options.exposePorts.forEach(port => {
      content += `      - "${port}:${port}"\n`;
    });

    content += `    environment:\n      - NODE_ENV=production\n`;

    if (options.healthCheck) {
      content += `    healthcheck:\n      test: ["CMD", "curl", "-f", "http://localhost:${options.port}/health"]\n      interval: 30s\n      timeout: 10s\n      retries: 3\n`;
    }

    content += `    networks:\n      - mcp-network\n\nnetworks:\n  mcp-network:\n    driver: bridge\n`;

    return content;
  }, [options, sanitizedServerName]);

  // Generate .env.example
  const envExample = useMemo(() => {
    return `# ${sanitizedServerName} Environment Variables\nPORT=${options.port}\nNODE_ENV=production\n`;
  }, [options.port, sanitizedServerName]);

  const config: DockerConfig = useMemo(
    () => ({
      dockerfile,
      dockerCompose,
      envExample,
      buildCommand: `docker build -t ${sanitizedServerName}:latest .`,
      runCommand: `docker run -d --name ${sanitizedServerName} -p ${options.port}:${options.port} ${sanitizedServerName}:latest`,
      serverName: sanitizedServerName,
    }),
    [dockerfile, dockerCompose, envExample, sanitizedServerName, options.port]
  );

  const downloadFile = useCallback((content: string, filename: string) => {
    const blob = new Blob([content], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }, []);

  const downloadAll = useCallback(() => {
    downloadFile(dockerfile, 'Dockerfile');
    downloadFile(dockerCompose, 'docker-compose.yml');
    downloadFile(envExample, '.env.example');
  }, [dockerfile, dockerCompose, envExample, downloadFile]);

  return {
    options,
    config,
    setOptions,
    resetOptions,
    downloadAll,
  };
}
