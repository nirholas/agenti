/**
 * @fileoverview Docker and Docker Compose file generator for MCP servers
 * @copyright Copyright (c) 2024-2026 nirholas
 * @license MIT
 */

import type { GenerationResult, ExtractedTool, OutputLanguage } from './types';

export interface DockerOptions {
  /** Base image for the Docker container */
  baseImage?: string;
  /** Port to expose */
  port?: number;
  /** Environment variables */
  env?: Record<string, string>;
  /** Additional labels */
  labels?: Record<string, string>;
  /** Health check configuration */
  healthCheck?: {
    interval?: string;
    timeout?: string;
    retries?: number;
    startPeriod?: string;
  };
}

export interface DockerComposeOptions extends DockerOptions {
  /** Service name */
  serviceName?: string;
  /** Networks to connect to */
  networks?: string[];
  /** Volumes to mount */
  volumes?: string[];
  /** Depends on other services */
  dependsOn?: string[];
  /** Enable Redis cache service */
  includeRedis?: boolean;
}

/**
 * Docker file generator for MCP servers
 */
export class DockerGenerator {
  /**
   * Generate a Dockerfile for the MCP server
   */
  generateDockerfile(result: GenerationResult, language?: OutputLanguage, options: DockerOptions = {}): string {
    const outputLanguage = language || 'typescript';
    
    if (outputLanguage === 'python') {
      return this.generatePythonDockerfile(result, options);
    }
    
    return this.generateTypescriptDockerfile(result, options);
  }

  /**
   * Generate TypeScript/Node.js Dockerfile
   */
  private generateTypescriptDockerfile(result: GenerationResult, options: DockerOptions): string {
    const port = options.port || 3000;
    const baseImage = options.baseImage || 'node:20-alpine';
    const envVars = options.env || {};
    const labels = options.labels || {};
    const healthCheck = options.healthCheck || {};

    const envLines = Object.entries(envVars)
      .map(([key, value]) => `ENV ${key}="${value}"`)
      .join('\n');

    const labelLines = Object.entries({
      'org.opencontainers.image.title': `${result.name}-mcp-server`,
      'org.opencontainers.image.description': result.metadata.description || `MCP server for ${result.repo}`,
      'org.opencontainers.image.source': `https://github.com/${result.repo}`,
      'maintainer': 'Generated by @nirholas/github-to-mcp',
      ...labels
    }).map(([key, value]) => `LABEL ${key}="${value}"`).join('\n');

    const healthCheckCmd = healthCheck.interval ? `
# Health check
HEALTHCHECK --interval=${healthCheck.interval || '30s'} \\
  --timeout=${healthCheck.timeout || '10s'} \\
  --start-period=${healthCheck.startPeriod || '5s'} \\
  --retries=${healthCheck.retries || 3} \\
  CMD node -e "process.exit(0)"
` : '';

    return `# Auto-generated Dockerfile for ${result.name} MCP Server
# Generated by @nirholas/github-to-mcp

# Build stage
FROM ${baseImage} AS builder

WORKDIR /app

# Install dependencies
COPY package*.json ./
COPY pnpm-lock.yaml* ./

# Use pnpm if available, fallback to npm
RUN corepack enable pnpm 2>/dev/null || npm install -g pnpm
RUN pnpm install --frozen-lockfile || npm ci

# Copy source code
COPY . .

# Build TypeScript
RUN pnpm build || npm run build

# Production stage
FROM ${baseImage} AS production

WORKDIR /app

# Create non-root user
RUN addgroup -g 1001 -S nodejs && \\
    adduser -S mcpserver -u 1001

# Copy built files and dependencies
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/node_modules ./node_modules
COPY --from=builder /app/package.json ./

${labelLines}

${envLines ? envLines + '\n' : ''}
# Set production environment
ENV NODE_ENV=production
ENV PORT=${port}

# Expose port
EXPOSE ${port}
${healthCheckCmd}
# Switch to non-root user
USER mcpserver

# Start the MCP server
CMD ["node", "dist/index.js"]
`;
  }

  /**
   * Generate Python Dockerfile
   */
  private generatePythonDockerfile(result: GenerationResult, options: DockerOptions): string {
    const port = options.port || 8000;
    const baseImage = options.baseImage || 'python:3.11-slim';
    const envVars = options.env || {};
    const labels = options.labels || {};
    const healthCheck = options.healthCheck || {};

    const envLines = Object.entries(envVars)
      .map(([key, value]) => `ENV ${key}="${value}"`)
      .join('\n');

    const labelLines = Object.entries({
      'org.opencontainers.image.title': `${result.name}-mcp-server`,
      'org.opencontainers.image.description': result.metadata.description || `MCP server for ${result.repo}`,
      'org.opencontainers.image.source': `https://github.com/${result.repo}`,
      'maintainer': 'Generated by @nirholas/github-to-mcp',
      ...labels
    }).map(([key, value]) => `LABEL ${key}="${value}"`).join('\n');

    const healthCheckCmd = healthCheck.interval ? `
# Health check
HEALTHCHECK --interval=${healthCheck.interval || '30s'} \\
  --timeout=${healthCheck.timeout || '10s'} \\
  --start-period=${healthCheck.startPeriod || '5s'} \\
  --retries=${healthCheck.retries || 3} \\
  CMD python -c "import sys; sys.exit(0)"
` : '';

    return `# Auto-generated Dockerfile for ${result.name} MCP Server (Python)
# Generated by @nirholas/github-to-mcp

# Build stage
FROM ${baseImage} AS builder

WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y --no-install-recommends \\
    build-essential \\
    && rm -rf /var/lib/apt/lists/*

# Install Python dependencies
COPY requirements.txt ./
RUN pip install --no-cache-dir --user -r requirements.txt

# Production stage
FROM ${baseImage} AS production

WORKDIR /app

# Create non-root user
RUN useradd -m -u 1001 mcpserver

# Copy Python packages from builder
COPY --from=builder /root/.local /home/mcpserver/.local

# Copy source code
COPY . .

# Change ownership
RUN chown -R mcpserver:mcpserver /app

${labelLines}

${envLines ? envLines + '\n' : ''}
# Set production environment
ENV PYTHONUNBUFFERED=1
ENV PYTHONDONTWRITEBYTECODE=1
ENV PATH=/home/mcpserver/.local/bin:$PATH
ENV PORT=${port}

# Expose port
EXPOSE ${port}
${healthCheckCmd}
# Switch to non-root user
USER mcpserver

# Start the MCP server
CMD ["python", "-m", "mcp_server"]
`;
  }

  /**
   * Generate Docker Compose configuration
   */
  generateDockerCompose(result: GenerationResult, language?: OutputLanguage, options: DockerComposeOptions = {}): string {
    const outputLanguage = language || 'typescript';
    const serviceName = options.serviceName || this.sanitizeServiceName(result.name);
    const port = options.port || (outputLanguage === 'python' ? 8000 : 3000);
    const networks = options.networks || ['mcp-network'];
    const volumes = options.volumes || [];
    const dependsOn = options.dependsOn || [];
    const envVars = options.env || {};
    const includeRedis = options.includeRedis || false;

    const envLines = Object.entries({
      NODE_ENV: 'production',
      ...envVars
    }).map(([key, value]) => `      ${key}: "${value}"`).join('\n');

    const volumeLines = volumes.length > 0
      ? `    volumes:\n${volumes.map(v => `      - ${v}`).join('\n')}`
      : '';

    const dependsOnLines = dependsOn.length > 0 || includeRedis
      ? `    depends_on:\n${[...dependsOn, ...(includeRedis ? ['redis'] : [])].map(d => `      - ${d}`).join('\n')}`
      : '';

    const networkLines = networks.length > 0
      ? `    networks:\n${networks.map(n => `      - ${n}`).join('\n')}`
      : '';

    const redisService = includeRedis ? `
  redis:
    image: redis:7-alpine
    restart: unless-stopped
    ports:
      - "6379:6379"
    volumes:
      - redis-data:/data
    networks:
      - ${networks[0] || 'mcp-network'}
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
` : '';

    const redisVolume = includeRedis ? '\n  redis-data:' : '';

    return `# Auto-generated Docker Compose for ${result.name} MCP Server
# Generated by @nirholas/github-to-mcp

version: '3.8'

services:
  ${serviceName}:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: ${serviceName}-mcp
    restart: unless-stopped
    ports:
      - "${port}:${port}"
    environment:
${envLines}${includeRedis ? '\n      REDIS_URL: "redis://redis:6379"' : ''}
${volumeLines}
${dependsOnLines}
${networkLines}
    healthcheck:
      test: ["CMD", "${outputLanguage === 'python' ? 'python' : 'node'}", "-e", "${outputLanguage === 'python' ? 'import sys; sys.exit(0)' : 'process.exit(0)'}"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s
${redisService}
networks:
  ${networks[0] || 'mcp-network'}:
    driver: bridge

volumes:
  ${serviceName}-data:${redisVolume}
`;
  }

  /**
   * Generate a multi-service Docker Compose with additional infrastructure
   */
  generateDockerComposeWithInfra(
    result: GenerationResult,
    language?: OutputLanguage,
    options: DockerComposeOptions & { includeTraefik?: boolean; includePrometheus?: boolean } = {}
  ): string {
    const baseCompose = this.generateDockerCompose(result, language, { ...options, includeRedis: true });
    
    const serviceName = options.serviceName || this.sanitizeServiceName(result.name);
    const networks = options.networks || ['mcp-network'];

    let additionalServices = '';

    if (options.includeTraefik) {
      additionalServices += `
  traefik:
    image: traefik:v2.10
    container_name: traefik
    restart: unless-stopped
    command:
      - "--api.insecure=true"
      - "--providers.docker=true"
      - "--providers.docker.exposedbydefault=false"
      - "--entrypoints.web.address=:80"
    ports:
      - "80:80"
      - "8080:8080"
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
    networks:
      - ${networks[0] || 'mcp-network'}
`;
    }

    if (options.includePrometheus) {
      additionalServices += `
  prometheus:
    image: prom/prometheus:latest
    container_name: prometheus
    restart: unless-stopped
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus-data:/prometheus
    networks:
      - ${networks[0] || 'mcp-network'}
`;
    }

    // Insert additional services before networks section
    if (additionalServices) {
      const networkIndex = baseCompose.indexOf('\nnetworks:');
      const volumeSection = options.includePrometheus ? '\n  prometheus-data:' : '';
      
      return baseCompose.slice(0, networkIndex) + 
             additionalServices + 
             baseCompose.slice(networkIndex).replace(/^(volumes:[\s\S]*?)$/m, `$1${volumeSection}`);
    }

    return baseCompose;
  }

  /**
   * Generate .dockerignore file
   */
  generateDockerIgnore(): string {
    return `# Auto-generated .dockerignore
# Generated by @nirholas/github-to-mcp

# Dependencies
node_modules/
.pnp
.pnp.js

# Testing
coverage/
.nyc_output/

# Build outputs (except dist)
*.tsbuildinfo

# Environment files
.env
.env.local
.env.*.local

# IDE
.idea/
.vscode/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# Git
.git/
.gitignore

# Documentation
docs/
*.md
!README.md

# Tests
**/*.test.ts
**/*.spec.ts
**/__tests__/

# Misc
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.cache/
tmp/
`;
  }

  /**
   * Generate requirements.txt for Python projects
   */
  generateRequirementsTxt(result: GenerationResult): string {
    return `# Auto-generated requirements.txt for ${result.name} MCP Server
# Generated by @nirholas/github-to-mcp

mcp>=1.0.0
httpx>=0.25.0
pydantic>=2.0.0
python-dotenv>=1.0.0
`;
  }

  /**
   * Sanitize service name for Docker Compose
   */
  private sanitizeServiceName(name: string): string {
    return name
      .toLowerCase()
      .replace(/[^a-z0-9-]/g, '-')
      .replace(/--+/g, '-')
      .replace(/^-|-$/g, '');
  }
}

// Export singleton instance
export const dockerGenerator = new DockerGenerator();

// Export function for convenience
export function generateDockerfile(result: GenerationResult, language?: OutputLanguage, options?: DockerOptions): string {
  return dockerGenerator.generateDockerfile(result, language, options);
}

export function generateDockerCompose(result: GenerationResult, language?: OutputLanguage, options?: DockerComposeOptions): string {
  return dockerGenerator.generateDockerCompose(result, language, options);
}
