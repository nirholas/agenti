/**
 * @fileoverview Go MCP server code generator
 * @copyright Copyright (c) 2024-2026 nirholas
 * @license MIT
 */

import type { ExtractedTool } from './types';

/**
 * Generate Go MCP server code from tools
 */
export class GoGenerator {
  /**
   * Generate complete Go MCP server code
   */
  generateServer(tools: ExtractedTool[], repoName: string, owner: string): string {
    const toolDefinitions = this.generateToolDefinitions(tools);
    const toolHandlers = this.generateToolHandlers(tools, owner, repoName);
    const moduleName = this.sanitizeModuleName(repoName);
    
    return `// Auto-generated MCP server for ${repoName}
// Generated by @nirholas/github-to-mcp

package main

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"

	"github.com/mark3labs/mcp-go/mcp"
	"github.com/mark3labs/mcp-go/server"
)

func main() {
	// Create server instance
	s := server.NewMCPServer(
		"${moduleName}-mcp",
		"1.0.0",
		server.WithResourceCapabilities(true, true),
		server.WithPromptCapabilities(true),
		server.WithToolCapabilities(true),
	)

	// Register tools
	registerTools(s)

	// Start stdio server
	if err := server.ServeStdio(s); err != nil {
		fmt.Fprintf(os.Stderr, "Server error: %v\\n", err)
		os.Exit(1)
	}
}

func registerTools(s *server.MCPServer) {
${toolDefinitions}
}

// Tool handler implementations
${toolHandlers}

// Helper function to make HTTP requests
func httpGet(url string, headers map[string]string) ([]byte, error) {
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return nil, err
	}
	
	for key, value := range headers {
		req.Header.Set(key, value)
	}
	
	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	
	if resp.StatusCode >= 400 {
		return nil, fmt.Errorf("HTTP error: %d", resp.StatusCode)
	}
	
	return io.ReadAll(resp.Body)
}

// Helper function to format JSON response
func formatJSON(data interface{}) string {
	bytes, err := json.MarshalIndent(data, "", "  ")
	if err != nil {
		return fmt.Sprintf("%v", data)
	}
	return string(bytes)
}
`;
  }

  /**
   * Generate Go tool definitions
   */
  private generateToolDefinitions(tools: ExtractedTool[]): string {
    return tools.map(tool => {
      const schemaJSON = JSON.stringify({
        type: 'object',
        properties: tool.inputSchema.properties || {},
        required: tool.inputSchema.required || [],
      }, null, 2).replace(/"/g, '`');

      return `	// Register ${tool.name}
	s.AddTool(
		mcp.NewTool("${tool.name}",
			mcp.WithDescription("${this.escapeString(tool.description)}"),
			mcp.WithString("inputSchema",
				mcp.Description("Input schema for the tool"),
			),
		),
		handle${this.toPascalCase(tool.name)},
	)`;
    }).join('\n\n');
  }

  /**
   * Generate tool handler functions
   */
  private generateToolHandlers(tools: ExtractedTool[], owner: string, repo: string): string {
    return tools.map(tool => {
      const funcName = `handle${this.toPascalCase(tool.name)}`;
      const impl = this.generateGoImplementation(tool, owner, repo);
      
      return `func ${funcName}(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	arguments := request.Params.Arguments
${impl}
}`;
    }).join('\n\n');
  }

  /**
   * Generate Go implementation for a tool
   */
  private generateGoImplementation(tool: ExtractedTool, owner: string, repo: string): string {
    // Check if it's a universal tool
    if (tool.source.type === 'universal') {
      return this.generateUniversalToolGo(tool.name, owner, repo);
    }

    // Check if it's a GraphQL tool
    if (tool.source.type === 'graphql') {
      return this.generateGraphQLToolGo(tool);
    }

    // Default implementation
    return `	// TODO: Implement ${tool.name}
	return mcp.NewToolResultText(fmt.Sprintf("Tool ${tool.name} called with args: %v", arguments)), nil`;
  }

  /**
   * Generate Go code for universal tools
   */
  private generateUniversalToolGo(name: string, owner: string, repo: string): string {
    switch (name) {
      case 'get_readme':
        return `	url := "https://api.github.com/repos/${owner}/${repo}/readme"
	headers := map[string]string{"Accept": "application/vnd.github.raw"}
	
	body, err := httpGet(url, headers)
	if err != nil {
		return mcp.NewToolResultError(-1, fmt.Sprintf("Failed to fetch README: %v", err)), nil
	}
	
	return mcp.NewToolResultText(string(body)), nil`;

      case 'list_files':
        return `	path, _ := arguments["path"].(string)
	url := fmt.Sprintf("https://api.github.com/repos/${owner}/${repo}/contents/%s", path)
	
	body, err := httpGet(url, nil)
	if err != nil {
		return mcp.NewToolResultError(-1, fmt.Sprintf("Failed to list files: %v", err)), nil
	}
	
	var files []map[string]interface{}
	if err := json.Unmarshal(body, &files); err != nil {
		// Single file response
		var file map[string]interface{}
		if err := json.Unmarshal(body, &file); err != nil {
			return mcp.NewToolResultError(-1, fmt.Sprintf("Failed to parse response: %v", err)), nil
		}
		files = []map[string]interface{}{file}
	}
	
	result := make([]map[string]string, 0, len(files))
	for _, f := range files {
		result = append(result, map[string]string{
			"name": f["name"].(string),
			"type": f["type"].(string),
			"path": f["path"].(string),
		})
	}
	
	return mcp.NewToolResultText(formatJSON(result)), nil`;

      case 'read_file':
        return `	path, _ := arguments["path"].(string)
	url := fmt.Sprintf("https://api.github.com/repos/${owner}/${repo}/contents/%s", path)
	headers := map[string]string{"Accept": "application/vnd.github.raw"}
	
	body, err := httpGet(url, headers)
	if err != nil {
		return mcp.NewToolResultError(-1, fmt.Sprintf("Failed to read file: %v", err)), nil
	}
	
	return mcp.NewToolResultText(string(body)), nil`;

      case 'search_code':
        return `	query, _ := arguments["query"].(string)
	url := fmt.Sprintf("https://api.github.com/search/code?q=%s+repo:${owner}/${repo}", query)
	
	body, err := httpGet(url, nil)
	if err != nil {
		return mcp.NewToolResultError(-1, fmt.Sprintf("Failed to search code: %v", err)), nil
	}
	
	var data struct {
		Items []struct {
			Path    string \`json:"path"\`
			HtmlURL string \`json:"html_url"\`
		} \`json:"items"\`
	}
	
	if err := json.Unmarshal(body, &data); err != nil {
		return mcp.NewToolResultError(-1, fmt.Sprintf("Failed to parse response: %v", err)), nil
	}
	
	if len(data.Items) == 0 {
		return mcp.NewToolResultText(fmt.Sprintf("No results found for: %s", query)), nil
	}
	
	results := make([]map[string]string, 0, 10)
	for i, item := range data.Items {
		if i >= 10 {
			break
		}
		results = append(results, map[string]string{
			"file": item.Path,
			"url":  item.HtmlURL,
		})
	}
	
	return mcp.NewToolResultText(formatJSON(results)), nil`;

      default:
        return `	return mcp.NewToolResultText(fmt.Sprintf("Tool ${name} not implemented")), nil`;
    }
  }

  /**
   * Generate Go code for GraphQL tools
   */
  private generateGraphQLToolGo(tool: ExtractedTool): string {
    return `	// GraphQL query execution
	query := \`${tool.implementation?.match(/query = \`([^`]+)\`/)?.[1] || 'query { __typename }'}\`
	
	// TODO: Implement GraphQL request
	return mcp.NewToolResultText(fmt.Sprintf("GraphQL tool %s: %v", "${tool.name}", query)), nil`;
  }

  /**
   * Generate go.mod content
   */
  generateGoMod(repoName: string): string {
    const moduleName = this.sanitizeModuleName(repoName);
    return `module ${moduleName}-mcp

go 1.21

require github.com/mark3labs/mcp-go v0.6.0
`;
  }

  /**
   * Generate README content
   */
  generateReadme(repoName: string, owner: string): string {
    const moduleName = this.sanitizeModuleName(repoName);
    return `# ${repoName} MCP Server (Go)

Auto-generated MCP server for interacting with the ${owner}/${repoName} GitHub repository.

## Installation

\`\`\`bash
go build -o ${moduleName}-mcp .
\`\`\`

## Usage

### With Claude Desktop

Add to your \`claude_desktop_config.json\`:

\`\`\`json
{
  "mcpServers": {
    "${moduleName}": {
      "command": "/path/to/${moduleName}-mcp"
    }
  }
}
\`\`\`

### Standalone

\`\`\`bash
./${moduleName}-mcp
\`\`\`

## Dependencies

- [mcp-go](https://github.com/mark3labs/mcp-go) - Go SDK for Model Context Protocol

## License

MIT
`;
  }

  /**
   * Convert tool name to PascalCase for Go function names
   */
  private toPascalCase(name: string): string {
    return name
      .split(/[-_]/)
      .map(part => part.charAt(0).toUpperCase() + part.slice(1))
      .join('');
  }

  /**
   * Sanitize module name for Go
   */
  private sanitizeModuleName(name: string): string {
    return name.toLowerCase().replace(/[^a-z0-9-]/g, '-').replace(/--+/g, '-');
  }

  /**
   * Escape string for Go
   */
  private escapeString(str: string): string {
    return str
      .replace(/\\/g, '\\\\')
      .replace(/"/g, '\\"')
      .replace(/\n/g, '\\n');
  }
}
