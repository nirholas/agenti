/**
 * @fileoverview Python MCP server code generator
 * @copyright Copyright (c) 2024-2026 nirholas
 * @license MIT
 */

import type { ExtractedTool } from './types';

/**
 * Generate Python MCP server code from tools
 */
export class PythonGenerator {
  /**
   * Generate complete Python MCP server code
   */
  generateServer(tools: ExtractedTool[], repoName: string, owner: string): string {
    const toolDefinitions = this.generateToolDefinitions(tools);
    const toolHandlers = this.generateToolHandlers(tools, owner, repoName);
    
    return `"""
Auto-generated MCP server for ${repoName}
Generated by @nirholas/github-to-mcp
"""

import asyncio
import json
from typing import Any, Optional
from mcp.server import Server
from mcp.server.stdio import stdio_server
from mcp.types import Tool, TextContent

# Create server instance
server = Server("${repoName}-mcp")

# Tool definitions
TOOLS = [
${toolDefinitions}
]

@server.list_tools()
async def list_tools() -> list[Tool]:
    """List all available tools."""
    return TOOLS

@server.call_tool()
async def call_tool(name: str, arguments: dict[str, Any]) -> list[TextContent]:
    """Handle tool calls."""
${toolHandlers}
    else:
        raise ValueError(f"Unknown tool: {name}")

async def main():
    """Run the MCP server."""
    async with stdio_server() as (read_stream, write_stream):
        await server.run(
            read_stream,
            write_stream,
            server.create_initialization_options()
        )

if __name__ == "__main__":
    asyncio.run(main())
`;
  }

  /**
   * Generate Python tool definitions
   */
  private generateToolDefinitions(tools: ExtractedTool[]): string {
    return tools.map(tool => {
      const propsStr = this.formatProperties(tool.inputSchema.properties || {});
      const requiredStr = JSON.stringify(tool.inputSchema.required || []);
      
      return `    Tool(
        name="${tool.name}",
        description="${this.escapeString(tool.description)}",
        inputSchema={
            "type": "object",
            "properties": ${propsStr},
            "required": ${requiredStr}
        }
    )`;
    }).join(',\n');
  }

  /**
   * Format properties dict for Python
   */
  private formatProperties(properties: Record<string, any>): string {
    if (Object.keys(properties).length === 0) return '{}';
    
    const entries = Object.entries(properties).map(([key, value]) => {
      return `"${key}": ${JSON.stringify(value)}`;
    });
    
    return `{\n            ${entries.join(',\n            ')}\n        }`;
  }

  /**
   * Generate tool handler switch/if statements
   */
  private generateToolHandlers(tools: ExtractedTool[], owner: string, repo: string): string {
    const handlers = tools.map((tool, index) => {
      const condition = index === 0 ? 'if' : 'elif';
      const impl = this.generatePythonImplementation(tool, owner, repo);
      
      return `    ${condition} name == "${tool.name}":
${impl}`;
    });
    
    return handlers.join('\n');
  }

  /**
   * Generate Python implementation for a tool
   */
  private generatePythonImplementation(tool: ExtractedTool, owner: string, repo: string): string {
    // Check if it's a universal tool
    if (tool.source.type === 'universal') {
      return this.generateUniversalToolPython(tool.name, owner, repo);
    }

    // Check if it's a GraphQL tool
    if (tool.source.type === 'graphql') {
      return this.generateGraphQLToolPython(tool);
    }

    // Default implementation
    return `        # TODO: Implement ${tool.name}
        return [TextContent(type="text", text=f"Tool ${tool.name} called with args: {arguments}")]`;
  }

  /**
   * Generate Python code for universal tools
   */
  private generateUniversalToolPython(name: string, owner: string, repo: string): string {
    switch (name) {
      case 'get_readme':
        return `        import httpx
        async with httpx.AsyncClient() as client:
            response = await client.get(
                "https://api.github.com/repos/${owner}/${repo}/readme",
                headers={"Accept": "application/vnd.github.raw"}
            )
            if response.status_code == 404:
                return [TextContent(type="text", text="No README found in this repository.")]
            response.raise_for_status()
            return [TextContent(type="text", text=response.text)]`;

      case 'list_files':
        return `        import httpx
        path = arguments.get("path", "")
        async with httpx.AsyncClient() as client:
            response = await client.get(
                f"https://api.github.com/repos/${owner}/${repo}/contents/{path}"
            )
            if response.status_code == 404:
                return [TextContent(type="text", text=f"Directory not found: {path or '/'}")]
            response.raise_for_status()
            data = response.json()
            files = [{"name": f["name"], "type": f["type"], "path": f["path"]} for f in data] if isinstance(data, list) else [data]
            return [TextContent(type="text", text=json.dumps(files, indent=2))]`;

      case 'read_file':
        return `        import httpx
        path = arguments.get("path", "")
        async with httpx.AsyncClient() as client:
            response = await client.get(
                f"https://api.github.com/repos/${owner}/${repo}/contents/{path}",
                headers={"Accept": "application/vnd.github.raw"}
            )
            if response.status_code == 404:
                return [TextContent(type="text", text=f"File not found: {path}. Use list_files to see available files.")]
            response.raise_for_status()
            return [TextContent(type="text", text=response.text)]`;

      case 'search_code':
        return `        import httpx
        query = arguments.get("query", "")
        async with httpx.AsyncClient() as client:
            response = await client.get(
                f"https://api.github.com/search/code?q={query}+repo:${owner}/${repo}"
            )
            if response.status_code == 403:
                return [TextContent(type="text", text="GitHub API rate limit exceeded. Try again later.")]
            if response.status_code == 422:
                return [TextContent(type="text", text="Search query invalid. Try a simpler search term.")]
            response.raise_for_status()
            data = response.json()
            if not data.get("items"):
                return [TextContent(type="text", text=f"No results found for: {query}")]
            results = [{"file": item["path"], "url": item["html_url"]} for item in data["items"][:10]]
            return [TextContent(type="text", text=json.dumps(results, indent=2))]`;

      default:
        return `        return [TextContent(type="text", text=f"Tool ${name} not implemented")]`;
    }
  }

  /**
   * Generate Python code for GraphQL tools
   */
  private generateGraphQLToolPython(tool: ExtractedTool): string {
    return `        import httpx
        query = """${tool.implementation?.match(/query = \`([^`]+)\`/)?.[1] || 'query { __typename }'}"""
        async with httpx.AsyncClient() as client:
            response = await client.post(
                "${tool.implementation?.match(/fetch\('([^']+)'/)?.[1] || '/graphql'}",
                json={"query": query, "variables": arguments}
            )
            response.raise_for_status()
            result = response.json()
            if result.get("errors"):
                return [TextContent(type="text", text="GraphQL errors: " + json.dumps(result["errors"], indent=2))]
            return [TextContent(type="text", text=json.dumps(result.get("data", {}), indent=2))]`;
  }

  /**
   * Generate requirements.txt content
   */
  generateRequirements(): string {
    return `mcp>=1.0.0
httpx>=0.27.0
`;
  }

  /**
   * Generate pyproject.toml content
   */
  generatePyproject(repoName: string): string {
    return `[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[project]
name = "${repoName}-mcp"
version = "1.0.0"
description = "Auto-generated MCP server for ${repoName}"
readme = "README.md"
requires-python = ">=3.10"
dependencies = [
    "mcp>=1.0.0",
    "httpx>=0.27.0",
]

[project.scripts]
${repoName}-mcp = "${repoName.replace(/-/g, '_')}_mcp:main"
`;
  }

  /**
   * Escape string for Python
   */
  private escapeString(str: string): string {
    return str
      .replace(/\\/g, '\\\\')
      .replace(/"/g, '\\"')
      .replace(/\n/g, '\\n');
  }
}
