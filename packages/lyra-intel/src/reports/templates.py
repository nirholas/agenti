"""
Report Templates - Reusable templates for reports.

Provides template strings and formatters for consistent report generation.
"""

from typing import Dict, Any, List
from datetime import datetime


class ReportTemplates:
    """
    Collection of report templates.
    
    Templates are designed to be consistent and professional,
    suitable for stakeholder presentations.
    """
    
    # Header templates
    HEADER = """# {title}

**Report Date:** {date}  
**Generated By:** Lyra Intel v{version}

---
"""
    
    # Table templates
    TABLE_HEADER = "| {headers} |"
    TABLE_SEPARATOR = "| {separators} |"
    TABLE_ROW = "| {values} |"
    
    # Section templates
    SECTION = """
## {title}

{content}
"""
    
    SUBSECTION = """
### {title}

{content}
"""
    
    # Metric templates
    METRIC_CARD = """
### {name}
**Value:** {value}  
**Status:** {status}
"""
    
    # Code block template
    CODE_BLOCK = """```{language}
{code}
```"""
    
    # Alert templates
    ALERT_CRITICAL = """
> ❌ **CRITICAL:** {message}
"""
    
    ALERT_WARNING = """
> ⚠️ **WARNING:** {message}
"""
    
    ALERT_INFO = """
> ℹ️ **INFO:** {message}
"""
    
    ALERT_SUCCESS = """
> ✅ **SUCCESS:** {message}
"""
    
    @classmethod
    def header(cls, title: str, version: str = "0.1.0") -> str:
        """Generate report header."""
        return cls.HEADER.format(
            title=title,
            date=datetime.now().strftime('%B %d, %Y'),
            version=version
        )
    
    @classmethod
    def table(cls, headers: List[str], rows: List[List[Any]]) -> str:
        """Generate markdown table."""
        lines = []
        
        # Header row
        lines.append("| " + " | ".join(str(h) for h in headers) + " |")
        
        # Separator
        lines.append("| " + " | ".join("-" * len(str(h)) for h in headers) + " |")
        
        # Data rows
        for row in rows:
            lines.append("| " + " | ".join(str(v) for v in row) + " |")
        
        return "\n".join(lines)
    
    @classmethod
    def section(cls, title: str, content: str) -> str:
        """Generate section."""
        return cls.SECTION.format(title=title, content=content)
    
    @classmethod
    def subsection(cls, title: str, content: str) -> str:
        """Generate subsection."""
        return cls.SUBSECTION.format(title=title, content=content)
    
    @classmethod
    def code_block(cls, code: str, language: str = "") -> str:
        """Generate code block."""
        return cls.CODE_BLOCK.format(code=code, language=language)
    
    @classmethod
    def metric_card(cls, name: str, value: Any, status: str = "-") -> str:
        """Generate metric card."""
        return cls.METRIC_CARD.format(name=name, value=value, status=status)
    
    @classmethod
    def alert(cls, level: str, message: str) -> str:
        """Generate alert box."""
        templates = {
            "critical": cls.ALERT_CRITICAL,
            "warning": cls.ALERT_WARNING,
            "info": cls.ALERT_INFO,
            "success": cls.ALERT_SUCCESS,
        }
        template = templates.get(level, cls.ALERT_INFO)
        return template.format(message=message)
    
    @classmethod
    def summary_box(cls, items: Dict[str, Any]) -> str:
        """Generate summary statistics box."""
        lines = ["| Metric | Value |", "| ------ | ----- |"]
        for key, value in items.items():
            lines.append(f"| {key} | {value} |")
        return "\n".join(lines)
    
    @classmethod
    def checklist(cls, items: List[tuple]) -> str:
        """
        Generate checklist.
        
        Args:
            items: List of (checked, text) tuples
        """
        lines = []
        for checked, text in items:
            marker = "[x]" if checked else "[ ]"
            lines.append(f"- {marker} {text}")
        return "\n".join(lines)
    
    @classmethod
    def progress_bar(cls, percentage: float, width: int = 20) -> str:
        """Generate text-based progress bar."""
        filled = int(width * percentage / 100)
        empty = width - filled
        bar = "█" * filled + "░" * empty
        return f"[{bar}] {percentage:.1f}%"
    
    @classmethod
    def tree(cls, structure: Dict, indent: int = 0) -> str:
        """Generate tree structure."""
        lines = []
        prefix = "  " * indent
        
        for key, value in structure.items():
            if isinstance(value, dict):
                lines.append(f"{prefix}├── {key}/")
                lines.append(cls.tree(value, indent + 1))
            else:
                lines.append(f"{prefix}├── {key}")
        
        return "\n".join(lines)
    
    @classmethod
    def comparison_table(cls, before: Dict, after: Dict, metrics: List[str]) -> str:
        """Generate before/after comparison table."""
        headers = ["Metric", "Before", "After", "Change"]
        rows = []
        
        for metric in metrics:
            before_val = before.get(metric, 0)
            after_val = after.get(metric, 0)
            
            if isinstance(before_val, (int, float)) and isinstance(after_val, (int, float)):
                change = after_val - before_val
                change_str = f"+{change}" if change > 0 else str(change)
            else:
                change_str = "-"
            
            rows.append([metric, before_val, after_val, change_str])
        
        return cls.table(headers, rows)
