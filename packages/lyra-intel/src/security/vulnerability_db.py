"""
Vulnerability Database - Known vulnerability tracking.

This module provides a database of known vulnerabilities
for dependency and code scanning.
"""

from dataclasses import dataclass, field
from datetime import datetime
from typing import Any, Dict, List, Optional
import json


@dataclass
class Vulnerability:
    """Represents a known vulnerability."""
    id: str
    package_name: str
    affected_versions: str
    severity: str
    title: str
    description: str
    patched_versions: Optional[str] = None
    cve_id: Optional[str] = None
    cwe_id: Optional[str] = None
    references: List[str] = field(default_factory=list)
    published_date: Optional[datetime] = None
    updated_date: Optional[datetime] = None


class VulnerabilityDatabase:
    """
    Database of known vulnerabilities.
    
    Features:
    - Track CVEs and security advisories
    - Match against dependencies
    - Update from external sources
    """
    
    def __init__(self):
        """Initialize vulnerability database."""
        self._vulnerabilities: Dict[str, List[Vulnerability]] = {}
        self._load_default_vulnerabilities()
    
    def _load_default_vulnerabilities(self) -> None:
        """Load some common known vulnerabilities."""
        # This would typically be loaded from an external source
        common_vulns = [
            Vulnerability(
                id="GHSA-example1",
                package_name="lodash",
                affected_versions="<4.17.21",
                severity="high",
                title="Prototype Pollution in lodash",
                description="Versions of lodash prior to 4.17.21 are vulnerable to prototype pollution",
                patched_versions=">=4.17.21",
                cve_id="CVE-2021-23337",
                cwe_id="CWE-1321",
            ),
            Vulnerability(
                id="GHSA-example2",
                package_name="axios",
                affected_versions="<0.21.1",
                severity="high",
                title="Server-Side Request Forgery in axios",
                description="Axios before 0.21.1 allows SSRF",
                patched_versions=">=0.21.1",
                cve_id="CVE-2020-28168",
                cwe_id="CWE-918",
            ),
            Vulnerability(
                id="GHSA-example3",
                package_name="requests",
                affected_versions="<2.20.0",
                severity="medium",
                title="HTTP Header Injection in requests",
                description="The requests package before 2.20.0 for Python sends credentials in cleartext",
                patched_versions=">=2.20.0",
                cve_id="CVE-2018-18074",
            ),
        ]
        
        for vuln in common_vulns:
            self.add_vulnerability(vuln)
    
    def add_vulnerability(self, vuln: Vulnerability) -> None:
        """Add a vulnerability to the database."""
        if vuln.package_name not in self._vulnerabilities:
            self._vulnerabilities[vuln.package_name] = []
        self._vulnerabilities[vuln.package_name].append(vuln)
    
    def get_vulnerabilities(self, package_name: str) -> List[Vulnerability]:
        """Get vulnerabilities for a package."""
        return self._vulnerabilities.get(package_name.lower(), [])
    
    def check_version(
        self,
        package_name: str,
        version: str,
    ) -> List[Vulnerability]:
        """
        Check if a package version has known vulnerabilities.
        
        Args:
            package_name: Name of the package
            version: Version to check
            
        Returns:
            List of applicable vulnerabilities
        """
        vulns = self.get_vulnerabilities(package_name.lower())
        affected = []
        
        for vuln in vulns:
            if self._version_matches(version, vuln.affected_versions):
                affected.append(vuln)
        
        return affected
    
    def _version_matches(self, version: str, version_spec: str) -> bool:
        """Check if a version matches a version specification."""
        # Simple version comparison (would use packaging library in production)
        try:
            if version_spec.startswith("<"):
                target = version_spec[1:]
                return self._compare_versions(version, target) < 0
            elif version_spec.startswith(">="):
                target = version_spec[2:]
                return self._compare_versions(version, target) >= 0
            elif version_spec.startswith("<="):
                target = version_spec[2:]
                return self._compare_versions(version, target) <= 0
            elif version_spec.startswith(">"):
                target = version_spec[1:]
                return self._compare_versions(version, target) > 0
            else:
                return version == version_spec
        except Exception:
            return False
    
    def _compare_versions(self, v1: str, v2: str) -> int:
        """Compare two version strings."""
        def normalize(v):
            return [int(x) for x in v.split(".") if x.isdigit()]
        
        parts1 = normalize(v1)
        parts2 = normalize(v2)
        
        # Pad to same length
        while len(parts1) < len(parts2):
            parts1.append(0)
        while len(parts2) < len(parts1):
            parts2.append(0)
        
        for a, b in zip(parts1, parts2):
            if a < b:
                return -1
            elif a > b:
                return 1
        return 0
    
    def scan_dependencies(
        self,
        dependencies: Dict[str, str],
    ) -> Dict[str, List[Vulnerability]]:
        """
        Scan dependencies for vulnerabilities.
        
        Args:
            dependencies: Dict of package_name -> version
            
        Returns:
            Dict of package_name -> list of vulnerabilities
        """
        results = {}
        
        for package, version in dependencies.items():
            vulns = self.check_version(package, version)
            if vulns:
                results[package] = vulns
        
        return results
    
    def import_from_json(self, json_data: str) -> int:
        """Import vulnerabilities from JSON."""
        data = json.loads(json_data)
        count = 0
        
        for item in data:
            vuln = Vulnerability(
                id=item.get("id", ""),
                package_name=item.get("package_name", ""),
                affected_versions=item.get("affected_versions", ""),
                severity=item.get("severity", "unknown"),
                title=item.get("title", ""),
                description=item.get("description", ""),
                patched_versions=item.get("patched_versions"),
                cve_id=item.get("cve_id"),
                cwe_id=item.get("cwe_id"),
                references=item.get("references", []),
            )
            self.add_vulnerability(vuln)
            count += 1
        
        return count
    
    def export_to_json(self) -> str:
        """Export vulnerabilities to JSON."""
        all_vulns = []
        
        for package_vulns in self._vulnerabilities.values():
            for vuln in package_vulns:
                all_vulns.append({
                    "id": vuln.id,
                    "package_name": vuln.package_name,
                    "affected_versions": vuln.affected_versions,
                    "severity": vuln.severity,
                    "title": vuln.title,
                    "description": vuln.description,
                    "patched_versions": vuln.patched_versions,
                    "cve_id": vuln.cve_id,
                    "cwe_id": vuln.cwe_id,
                    "references": vuln.references,
                })
        
        return json.dumps(all_vulns, indent=2)
    
    def get_statistics(self) -> Dict[str, Any]:
        """Get database statistics."""
        total = sum(len(v) for v in self._vulnerabilities.values())
        by_severity = {}
        
        for vulns in self._vulnerabilities.values():
            for v in vulns:
                by_severity[v.severity] = by_severity.get(v.severity, 0) + 1
        
        return {
            "total_vulnerabilities": total,
            "packages_tracked": len(self._vulnerabilities),
            "by_severity": by_severity,
        }
